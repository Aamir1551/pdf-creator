<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Алгоритм Диница нахождения максимального потока</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="/data/jquery.js"></script><script type="text/javascript" src="/data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php" >home</a></li><li><a href="../algo/" class=current>algo</a></li><li><a href="../bookz/" >bookz</a></li><li><a href="../forum/" >forum</a></li><li><a href="../about.php" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 13 Aug 2010 19:48<br>редактировано: 14 Jun 2012 5:01</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="#" id="contents-hide">[скрыть]</a><a href="#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Алгоритм Диница </h1><p><p><p><h2 style="padding-top:40px;"> Постановка задачи </h2><p>Пусть дана сеть, т.е. ориентированный граф <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G">, в котором каждому ребру <img class=tex src="../tex2png/cache/00e36d5afb42bb0ea9cc0e95d95c50da.png" alt="(u,v)"> приписана пропускная способность <img class=tex src="../tex2png/cache/e466103d510feb335972d742a79a64ef.png" alt="c_{uv}">, а также выделены две вершины &mdash; исток <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> и сток <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">.<p>Требуется найти в этой сети поток <img class=tex src="../tex2png/cache/3e5031727470787b9b924fdb787a1a8a.png" alt="f_{uv}"> из истока <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в сток <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> максимальной величины.<p><p><p><h2 style="padding-top:40px;"> Немного истории </h2><p>Этот алгоритм был опубликован советским (израильским) учёным Ефимом <b>Диницем</b> (Yefim Dinic, иногда пишется как "Dinitz") в 1970 г., т.е. даже на два года раньше опубликования алгоритма Эдмондса-Карпа (впрочем, оба алгоритма были независимо открыты в 1968 г.).<p>Кроме того, следует отметить, что некоторые упрощения алгоритма были произведены Шимоном Ивеном (Shimon <b>Even</b>) и его учеником Алоном Итаи (Alon <b>Itai</b>) в 1979 г. Именно благодаря им алгоритм получил свой современный облик: они применили к идее Диница концепцию блокирующих потоков Александра Карзанова (Alexander Karzanov, 1974 г.), а также переформулировали алгоритм к той комбинации обхода в ширину и в глубину, в которой сейчас этот алгоритм и излагается везде.<p>Развитие идей по отношению к потоковым алгоритмам крайне интересно рассматривать, учитывая <b>"железный занавес"</b> тех лет, разделявший СССР и Запад. Видно, как иногда похожие идеи появлялись почти одновременно (как в случае алгоритма Диница и алгоритма Эдмондса-Карпа), правда, имея при этом разную эффективность (алгоритм Диница на один порядок быстрее); иногда же, наоборот, появление идеи по одну сторону "занавеса" опережало аналогичный ход по другую сторону более чем на десятилетие (как алгоритм Карзанова проталкивания в 1974 г. и алгоритм Гольдберга (Goldberg) проталкивания в 1985 г.).<p><p><p><h2 style="padding-top:40px;"> Необходимые определения </h2><p>Введём три необходимых определения (каждое из них является независимым от остальных), которые затем будут использоваться в алгоритме Диница.<p><b>Остаточной сетью <img class=tex src="../tex2png/cache/2d04e5aaa11fa782185a0e482d18c599.png" alt="G^R"></b> по отношению к сети <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> и некоторому потоку <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> в ней называется сеть, в которой каждому ребру <img class=tex src="../tex2png/cache/7313fa61da522d6dcfb804b11bb02303.png" alt="(u,v) \in G"> с пропускной способностью <img class=tex src="../tex2png/cache/e466103d510feb335972d742a79a64ef.png" alt="c_{uv}"> и потоком <img class=tex src="../tex2png/cache/3e5031727470787b9b924fdb787a1a8a.png" alt="f_{uv}"> соответствуют два ребра:<p><ul><p><li><img class=tex src="../tex2png/cache/00e36d5afb42bb0ea9cc0e95d95c50da.png" alt="(u,v)"> с пропускной способностью <img class=tex src="../tex2png/cache/f2774667f380221ca7cf9a5937725cf7.png" alt="c_{uv}^R = c_{uv} - f_{uv}"><p><li><img class=tex src="../tex2png/cache/fae7fc7228760232ded84ec7bb795757.png" alt="(v,u)"> с пропускной способностью <img class=tex src="../tex2png/cache/c081bbbe2298b582b14d6f7bf3f2195e.png" alt="c_{vu}^R = f_{uv}"><p></ul><p>Стоит отметить, что при таком определении в остаточной сети могут появляться кратные рёбра: если в исходной сети было как ребро <img class=tex src="../tex2png/cache/00e36d5afb42bb0ea9cc0e95d95c50da.png" alt="(u,v)">, так и <img class=tex src="../tex2png/cache/fae7fc7228760232ded84ec7bb795757.png" alt="(v,u)">.<p>Остаточное ребро можно интуитивно понимать как меру того, насколько ещё можно увеличить поток вдоль какого-то ребра. В самом деле, если по ребру <img class=tex src="../tex2png/cache/00e36d5afb42bb0ea9cc0e95d95c50da.png" alt="(u,v)"> с пропускной способностью <img class=tex src="../tex2png/cache/e466103d510feb335972d742a79a64ef.png" alt="c_{uv}"> протекает поток <img class=tex src="../tex2png/cache/3e5031727470787b9b924fdb787a1a8a.png" alt="f_{uv}">, то потенциально по нему можно пропустить ещё <img class=tex src="../tex2png/cache/81abd4fe775e0ae2e9d04660d7b10223.png" alt="c_{uv}-f_{uv}"> единиц потока, а в обратную сторону можно пропустить до <img class=tex src="../tex2png/cache/3e5031727470787b9b924fdb787a1a8a.png" alt="f_{uv}"> единиц потока, что будет означать отмену потока в первоначальном направлении.<p><b>Блокирующим потоком</b> в данной сети называется такой поток, что любой путь из истока <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в сток <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> содержит насыщенное этим потоком ребро. Иными словами, в данной сети не найдётся такого пути из истока в сток, вдоль которого можно беспрепятственно увеличить поток.<p>Блокирующий поток не обязательно максимален. Теорема Форда-Фалкерсона говорит о том, что поток будет максимальным тогда и только тогда, когда в остаточной сети не найдётся <img class=tex src="../tex2png/cache/1ef2fc573f0914b03c3f83595ad5b905.png" alt="s-t"> пути; в блокирующем же потоке ничего не утверждается о существовании пути по рёбрам, появляющимся в остаточной сети.<p><b>Слоистая сеть</b> для данной сети строится следующим образом. Сначала определяются длины кратчайших путей из истока <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> до всех остальных вершин; назовём уровнем <img class=tex src="../tex2png/cache/3af66db6d15f64d610a605b82168c50f.png" alt="{\rm level}[v]"> вершины её расстояние от истока. Тогда в слоистую сеть включают все те рёбра <img class=tex src="../tex2png/cache/00e36d5afb42bb0ea9cc0e95d95c50da.png" alt="(u,v)"> исходной сети, которые ведут с одного уровня на какой-либо другой, более поздний, уровень, т.е. <img class=tex src="../tex2png/cache/497d21a2cb55c75efb1bb4adddb432d2.png" alt="{\rm level}[u] + 1 = {\rm level}[v]"> (почему в этом случае разница расстояний не может превосходить единицы, следует из свойства кратчайших расстояний). Таким образом, удаляются все рёбра, расположенные целиком внутри уровней, а также рёбра, ведущие назад, к предыдущим уровням.<p>Очевидно, слоистая сеть ациклична. Кроме того, любой <img class=tex src="../tex2png/cache/1ef2fc573f0914b03c3f83595ad5b905.png" alt="s-t"> путь в слоистой сети является кратчайшим путём в исходной сети.<p>Построить слоистую сеть по данной сети очень легко: для этого надо запустить обход в ширину по рёбрам этой сети, посчитав тем самым для каждой вершины величину <img class=tex src="../tex2png/cache/d78e498fc2b8304febac57b0be0dcb2e.png" alt="{\rm level}[]">, и затем внести в слоистую сеть все подходящие рёбра.<p>Примечание. Термин "слоистая сеть" в русскоязычной литературе не употребляется; обычно эта конструкция называется просто "вспомогательным графом". Впрочем, на английском языке обычно используется термин "layered network".<p><p><p><h2 style="padding-top:40px;"> Алгоритм </h2><p><p><h3 style="padding-top:15px;"> Схема алгоритма </h3><p>Алгоритм представляет собой несколько <b>фаз</b>. На каждой фазе сначала строится остаточная сеть, затем по отношению к ней строится слоистая сеть (обходом в ширину), а в ней ищется произвольный блокирующий поток. Найденный блокирующий поток прибавляется к текущему потоку, и на этом очередная итерация заканчивается.<p>Этот алгоритм схож с алгоритмом Эдмондса-Карпа, но основное отличие можно понимать так: на каждой итерации поток увеличивается не вдоль одного кратчайшего <img class=tex src="../tex2png/cache/1ef2fc573f0914b03c3f83595ad5b905.png" alt="s-t"> пути, а вдоль целого набора таких путей (ведь именно такими путями и являются пути в блокирующем потоке слоистой сети).<p><p><h3 style="padding-top:15px;"> Корректность алгоритма </h3><p>Покажем, что если алгоритм завершается, то на выходе у него получается поток именно максимальной величины.<p>В самом деле, предположим, что в какой-то момент в слоистой сети, построенной для остаточной сети, не удалось найти блокирующий поток. Это означает, что сток <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> вообще не достижим в слоистой сети из истока <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">. Но поскольку слоистая сеть содержит в себе все кратчайшие пути из истока в остаточной сети, это в свою очередь означает, что в остаточной сети нет пути из истока в сток. Следовательно, применяя теорему Форда-Фалкерсона, получаем, что текущий поток в самом деле максимален.<p><p><h3 style="padding-top:15px;"> Оценка числа фаз </h3><p>Покажем, что алгоритм Диница всегда выполняет <b>менее <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> фаз</b>. Для этого докажем две леммы:<p><b>Лемма 1</b>. Кратчайшее расстояние от истока до каждой вершины не уменьшается с выполнением каждой итерации, т.е.<p><p class=formula><img class=tex src="../tex2png/cache/b79ca81f5f477fe54b414571bbf75617.png" alt=" {\rm level}_{i+1}[v] \ge {\rm level}_i[v] "></p><p>где нижний индекс обозначает номер фазы, перед которой взяты значения этих переменных.<p><b>Доказательство</b>. Зафиксируем произвольную фазу <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i"> и произвольную вершину <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> и рассмотрим любой кратчайший <img class=tex src="../tex2png/cache/b7e759299be789fe45fa382a67db42e5.png" alt="s-v"> путь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> в сети <img class=tex src="../tex2png/cache/82818fc029a83c07c553a4032a4efa14.png" alt="G^R_{i+1}"> (напомним, так мы обозначаем остаточную сеть, взятую перед выполнением <img class=tex src="../tex2png/cache/4ec332d2c63d7695c3b676e8e6dd9881.png" alt="i+1">-ой фазы). Очевидно, длина пути <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> равна <img class=tex src="../tex2png/cache/1dc8d29487cc3b4eb638f6f3c26b392e.png" alt="{\rm level}_{i+1}[v]">.<p>Заметим, что в остаточную сеть <img class=tex src="../tex2png/cache/82818fc029a83c07c553a4032a4efa14.png" alt="G^R_{i+1}"> могут входить только рёбра из <img class=tex src="../tex2png/cache/2d04e5aaa11fa782185a0e482d18c599.png" alt="G^R">, а также рёбра, обратные рёбрам из <img class=tex src="../tex2png/cache/2d04e5aaa11fa782185a0e482d18c599.png" alt="G^R"> (это следует из определения остаточной сети). Рассмотрим два случая:<p><ul><li>Путь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> содержит только рёбра из <img class=tex src="../tex2png/cache/2d04e5aaa11fa782185a0e482d18c599.png" alt="G^R">. Тогда, понятно, длина пути <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> больше либо равна <img class=tex src="../tex2png/cache/8be2aa8dd31fa8ac98a16b5db0420b03.png" alt="{\rm level}_i[v]"> (потому что <img class=tex src="../tex2png/cache/8be2aa8dd31fa8ac98a16b5db0420b03.png" alt="{\rm level}_i[v]"> по определению &mdash; длина кратчайшего пути), что и означает выполнение неравенства.<li>Путь <img class=tex src="../tex2png/cache/bad23dd3e46f552bca69f71baf5d83f0.png" alt="P"> содержит как минимум одно ребро, не содержащееся в <img class=tex src="../tex2png/cache/2d04e5aaa11fa782185a0e482d18c599.png" alt="G^R"> (но обратное какому-то ребру из <img class=tex src="../tex2png/cache/2d04e5aaa11fa782185a0e482d18c599.png" alt="G^R">). Рассмотрим первое такое ребро; пусть это будет ребро <img class=tex src="../tex2png/cache/f99e316cf240271b4d3bc1e39fdeb6a4.png" alt="(u,w)">.<p><p class=formula><img class=tex src="../tex2png/cache/0ccc5c281eb06881f5fabfb4dc61265d.png" alt=" s \Longrightarrow u \rightarrow w \Longrightarrow[...]"></p><p>Мы можем применить нашу лемму к вершине <img class=tex src="../tex2png/cache/6d55e3b56ba7b5ce8ff4c00cb6fed744.png" alt="u">, потому что она подпадает под первый случай; итак, мы получаем неравенство <img class=tex src="../tex2png/cache/c47967b2d7859e8a4e786f57be15cfda.png" alt="{\rm level}_{i+1}[u] \ge {\rm level}_i[u]">.<p>Теперь заметим, что поскольку ребро <img class=tex src="../tex2png/cache/f99e316cf240271b4d3bc1e39fdeb6a4.png" alt="(u,w)"> появилось в остаточной сети только после выполнения <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой фазы, то отсюда следует, что вдоль ребра <img class=tex src="../tex2png/cache/4889fa373fca4b1b83a6b3eab574bf34.png" alt="(w,u)"> был дополнительно пропущен какой-то поток; следовательно, ребро <img class=tex src="../tex2png/cache/4889fa373fca4b1b83a6b3eab574bf34.png" alt="(w,u)"> принадлежало слоистой сети перед <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой фазой, а потому <img class=tex src="../tex2png/cache/16df0076ca9a5ffff228955c27687d45.png" alt="{\rm level}_i[u] = {\rm level}_i[w] + 1">. Учтём, что по свойству кратчайших путей <img class=tex src="../tex2png/cache/20410a08bea121ad9acee423c9d1875e.png" alt="{\rm level}_{i+1}[w] = {\rm level}_{i+1}[u] + 1">, и объединяя это равенство с двумя предыдущими неравенствами, получаем:<p><p class=formula><img class=tex src="../tex2png/cache/764f2ca8d8a03c08093a1508c469dbd7.png" alt=" {\rm level}_{i+1}[w] \ge {\rm level}_i[w] + 2. "></p><p>Теперь мы можем применять те же самые рассуждения ко всему оставшемуся пути до <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> (т.е. что каждое инвертированное ребро добавляет к <img class=tex src="../tex2png/cache/a10294681212e22874ff5a3950c53e1b.png" alt="\rm level"> как минимум два), и в итоге получим требуемое неравенство.<p></ul><p><b>Лемма 2</b>. Расстояние между истоком и стоком строго увеличивается после каждой фазы алгоритма, т.е.:<p><p class=formula><img class=tex src="../tex2png/cache/e5cc9b946180e0072f8cf999d90d0c12.png" alt=" {\rm level}^\prime[t] > {\rm level}[t], "></p><p>где штрихом помечено значение, полученное на следующей фазе алгоритма.<p><b>Доказательство</b>: от противного. Предположим, что после выполнения текущей фазы оказалось, что <img class=tex src="../tex2png/cache/92aecf5c0ccb94aedd0c8a92555d1168.png" alt=" {\rm level}^\prime[t] = {\rm level}[t] ">. Рассмотрим кратчайший путь из истока в сток; по предположению, его длина должна сохраниться неизменной. Однако остаточная сеть на следующей фазе содержит только рёбра остаточной сети перед выполнением текущей фазы, либо обратные к ним. Таким образом, пришли к противоречию: нашёлся <img class=tex src="../tex2png/cache/1ef2fc573f0914b03c3f83595ad5b905.png" alt="s-t"> путь, который не содержит насыщенных рёбер, и имеет ту же длину, что и кратчайший путь. Этот путь должен был быть "заблокирован" блокирующим потоком, чего не произошло, в чём и заключается противоречие, что и требовалось доказать.<p>Эту лемму интуитивно можно понимать следующим образом: на <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">-ой фазе алгоритм Диница выявляет и насыщает все <img class=tex src="../tex2png/cache/1ef2fc573f0914b03c3f83595ad5b905.png" alt="s-t"> пути длины <img class=tex src="../tex2png/cache/2d9d1096e116db33bc39a0accf4e9ef7.png" alt="i">.<p>Поскольку длина кратчайшего пути из <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> не может превосходить <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, то, следовательно, алгоритм Диница совершает <b>не более <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1"> фазы</b>.<p><p><h3 style="padding-top:15px;"> Поиск блокирующего потока </h3><p>Чтобы завершить построение алгоритма Диница, надо описать алгоритм нахождения блокирующего потока в слоистой сети &mdash; ключевое место алгоритма.<p>Мы рассмотрим три возможных варианта реализации поиска блокирующего потока:<p><ul><p><li>Искать <img class=tex src="../tex2png/cache/1ef2fc573f0914b03c3f83595ad5b905.png" alt="s-t"> пути по одному, пока такие пути находятся. Путь можно найти за <img class=tex src="../tex2png/cache/baa7e0765a2f4f8991346c62c1279993.png" alt="O(m)"> обходом в глубину, а всего таких путей будет <img class=tex src="../tex2png/cache/baa7e0765a2f4f8991346c62c1279993.png" alt="O(m)"> (поскольку каждый путь насыщает как минимум одно ребро). Итоговая асимптотика поиска одного блокирующего потока составит <img class=tex src="../tex2png/cache/4f99b6fa8e5c98deb2c6a24718ba3dad.png" alt="O(m^2)">.<p><li>Аналогично предыдущей идее, однако удалять в процессе обхода в глубину из графа все "лишние" рёбра, т.е. рёбра, вдоль которых не получится дойти до стока.<p>Это очень легко реализовать: достаточно удалять ребро после того, как мы просмотрели его в обходе в глубину (кроме того случая, когда мы прошли вдоль ребра и нашли путь до стока). С точки зрения реализации, надо просто поддерживать в списке смежности каждой вершины указатель на первое неудалённое ребро, и увеличивать этот указать в цикле внутри обхода в глубину.<p>Оценим асимптотику этого решения. Каждый обход в глубину завершается либо насыщением как минимум одного ребра (если этот обход достиг стока), либо продвижением вперёд как минимум одного указателя (в противном случае). Можно понять, что один запуск обхода в глубину из основной программы работает за <img class=tex src="../tex2png/cache/81259dc55a6c0de8ed964c7b7e27e76e.png" alt="O (k + n)">, где <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k"> &mdash; число продвижений указателей. Учитывая, что всего запусков обхода в глубину в рамках поиска одного блокирующего потока будет <img class=tex src="../tex2png/cache/5dd757225a4d1a7315bc81f231a4cf1e.png" alt="O (p)">, где <img class=tex src="../tex2png/cache/2f8934466bea85c9661745280df23800.png" alt="p"> &mdash; число рёбер, насыщенных этим блокирующим потоком, то весь алгоритм поиска блокирующего потока отработает за <img class=tex src="../tex2png/cache/633dd801f550d8f177fa172265e276d9.png" alt="O (p k + p n)">, что, учитывая, что все указатели в сумме прошли расстояние <img class=tex src="../tex2png/cache/08faf3b47d5f052931b9f4e825287711.png" alt="O (m)">, даёт асимптотику <img class=tex src="../tex2png/cache/5e0522d351cb662e7599b1a12b9aecb1.png" alt="O (m + pn)">. В худшем случае, когда блокирующий поток насыщает все рёбра, асимптотика получается <img class=tex src="../tex2png/cache/a6b2398465a599d7b0ac3127f16f0244.png" alt="O (n m)">; эта асимптотика и будет использоваться далее.<p>Можно сказать, что этот способ нахождения блокирующего потока чрезвычайно эффективен в том смысле, что на поиск одного увеличивающего пути он тратит <img class=tex src="../tex2png/cache/ad5a094bea72e51fb50321739f51ec0d.png" alt="O (n)"> операций в среднем. Именно в этом и кроется разность на целый порядок эффективностей алгоритма Диница и Эдмондса-Карпа (который ищет один увеличивающий путь за <img class=tex src="../tex2png/cache/08faf3b47d5f052931b9f4e825287711.png" alt="O (m)">).<p>Этот способ решения является по-прежнему простым для реализации, но достаточно эффективным, и потому наиболее часто применяется на практике.<p><li>Можно применить специальные структуры данных &mdash; динамические деревья Слетора (Sleator) и Тарьяна (Tarjan)). Тогда каждый блокирующий поток можно найти за время <img class=tex src="../tex2png/cache/7e96d223d53a300fbb71ff4b2bdbe603.png" alt="O (m \log n)">.<p></ul><p><p><h3 style="padding-top:15px;"> Асимптотика </h3><p>Таким образом, весь алгоритм Диница выполняется за <img class=tex src="../tex2png/cache/d4d1e418f4c9e576e780bd1de8e68006.png" alt="O (n^2 m)">, если блокирующий поток искать описанным выше способом за <img class=tex src="../tex2png/cache/a6b2398465a599d7b0ac3127f16f0244.png" alt="O (n m)">. Реализация с использованием динамических деревьев Слетора и Тарьяна будет работать за время <img class=tex src="../tex2png/cache/3b9eeea7ee7c62b894a964eb07220e69.png" alt="O (n m \log n)">.<p><h4> Единичные сети </h4><p>Единичной сетью ("unit network") называется такая сеть, в которой пропускные способности всех существующих рёбер равны единице, и у любой вершины, кроме истока и стока, либо входящее, либо исходящее ребро единственно.<p>Этот случай является достаточно важным, поскольку в задаче поиска <b>максимального паросочетания</b> построенная сеть является именно единичной.<p><b>Докажем</b>, что на единичных сетях алгоритм Диница даже в простой реализации (которая на произвольных графах отрабатывает за <img class=tex src="../tex2png/cache/d4d1e418f4c9e576e780bd1de8e68006.png" alt="O (n^2 m)">) работает за время <img class=tex src="../tex2png/cache/94afa9b7583edee8e8dc409667471d52.png" alt="O (m \sqrt{n})">, достигая на задаче поиска наибольшего паросочетания один из лучших известных алгоритмов &mdash; алгоритм Хопкрофта-Карпа.<p>Во-первых, отметим, что приведённый выше алгоритм поиска блокирующего потока, который на произвольных сетях работает за время <img class=tex src="../tex2png/cache/a6b2398465a599d7b0ac3127f16f0244.png" alt="O (n m)">, в сетях с единичными пропускными способностями будет работать за <img class=tex src="../tex2png/cache/08faf3b47d5f052931b9f4e825287711.png" alt="O (m)">: в силу того, что каждое ребро не будет просмотрено более одного раза.<p>Во-вторых, оценим общее количество фаз, которое могло произойти в случае единичных сетей.<p>Пусть уже было произведено <img class=tex src="../tex2png/cache/59924d89d7dd54098a99b85b4e3cda4b.png" alt="\sqrt{n}"> фаз алгоритма Диница; тогда все увеличивающие пути длины не более <img class=tex src="../tex2png/cache/59924d89d7dd54098a99b85b4e3cda4b.png" alt="\sqrt{n}"> уже обнаружены. Пусть <img class=tex src="../tex2png/cache/51571962341478345d68f00e6a1702dc.png" alt="f"> &mdash; текущий найденный поток, а <img class=tex src="../tex2png/cache/9922a5368cf0e6ccbde2b8fe883ba1a2.png" alt="f^*"> &mdash; искомый максимальный поток; рассмотрим их разность: <img class=tex src="../tex2png/cache/9820b52fa3d6fc4ec6ef48db85382565.png" alt="f^* - f">. Она представляет из себя поток в остаточной сети <img class=tex src="../tex2png/cache/2d04e5aaa11fa782185a0e482d18c599.png" alt="G^R">. Этот поток имеет величину <img class=tex src="../tex2png/cache/41cc8c6757cdb48f13e10dbfe91c723c.png" alt="|f^*| - |f|">, и вдоль каждого ребра равен нулю или единице. Его можно декомпозировать на набор из <img class=tex src="../tex2png/cache/41cc8c6757cdb48f13e10dbfe91c723c.png" alt="|f^*| - |f|"> путей из <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s"> в <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t"> и, возможно, циклов. Поскольку сеть единична, то все эти пути не могут иметь общих вершин, поэтому, учитывая вышесказанное, суммарное количество вершин в них <img class=tex src="../tex2png/cache/9ef23f4e3d2645d9f049553d5dc6dd17.png" alt="cnt"> можно оценить как:<p><p class=formula><img class=tex src="../tex2png/cache/091d7a8c0bec6165bb7970e94558f5d5.png" alt=" cnt \ge (|f^*| - |f|) \cdot \sqrt{n}. "></p><p>С другой стороны, учитывая, что <img class=tex src="../tex2png/cache/d0b1203c5307a91c39451507a6b65e3f.png" alt="cnt \le n">, мы получаем отсюда:<p><p class=formula><img class=tex src="../tex2png/cache/0d49ee73a8a6835339a1e4ee650d9382.png" alt=" |f^*| - |f| \le \sqrt{n}, "></p><p>что означает, что ещё через <img class=tex src="../tex2png/cache/59924d89d7dd54098a99b85b4e3cda4b.png" alt="\sqrt{n}"> фаз алгоритма Диница гарантированно найдётся максимальный поток.<p>Следовательно, общее число фаз алгоритма Диница, выполняемое на единичных сетях, можно оценить как <img class=tex src="../tex2png/cache/caa6f8182d2214c24088f526d53e3489.png" alt="2 \sqrt{n}">, что и требовалось доказать.<p><p><p><h2 style="padding-top:40px;"> Реализация </h2><p>Приведём две реализации алгоритма за <img class=tex src="../tex2png/cache/d4d1e418f4c9e576e780bd1de8e68006.png" alt="O (n^2 m)">, работающие на сетях, заданных матрицами смежности и списками смежности соответственно.<p><p><h3 style="padding-top:15px;"> Реализация над графами в виде матриц смежности </h3><p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> ...<span class="sy4">;</span> <span class="co1">// число вершин</span>
<span class="kw4">const</span> <span class="kw4">int</span> INF <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span> <span class="co1">// константа-бесконечность</span>
&nbsp;
<span class="kw4">int</span> n, c<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, f<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, s, t, d<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, ptr<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, q<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">bool</span> bfs<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> qh<span class="sy1">=</span><span class="nu0">0</span>, qt<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
	q<span class="br0">&#91;</span>qt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> s<span class="sy4">;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>d, <span class="sy2">-</span><span class="nu0">1</span>, n <span class="sy2">*</span> <span class="kw3">sizeof</span> d<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	d<span class="br0">&#91;</span>s<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>qh <span class="sy1">&lt;</span> qt<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> v <span class="sy1">=</span> q<span class="br0">&#91;</span>qh<span class="sy2">++</span><span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> to<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> to<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>to<span class="br0">&#41;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> f<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">&lt;</span> c<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				q<span class="br0">&#91;</span>qt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> to<span class="sy4">;</span>
				d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> d<span class="br0">&#91;</span>t<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> dfs <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> flow<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>flow<span class="br0">&#41;</span>  <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v <span class="sy1">==</span> t<span class="br0">&#41;</span>  <span class="kw1">return</span> flow<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">int</span> <span class="sy3">&amp;</span> to<span class="sy1">=</span>ptr<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy4">;</span> to<span class="sy1">&lt;</span>n<span class="sy4">;</span> <span class="sy2">++</span>to<span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">&#41;</span>  <span class="kw1">continue</span><span class="sy4">;</span>
		<span class="kw4">int</span> pushed <span class="sy1">=</span> dfs <span class="br0">&#40;</span>to, min <span class="br0">&#40;</span>flow, c<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy2">-</span> f<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>pushed<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			f<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy2">+</span><span class="sy1">=</span> pushed<span class="sy4">;</span>
			f<span class="br0">&#91;</span>to<span class="br0">&#93;</span><span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">-</span><span class="sy1">=</span> pushed<span class="sy4">;</span>
			<span class="kw1">return</span> pushed<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> dinic<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> flow <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>bfs<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
		<span class="kw3">memset</span> <span class="br0">&#40;</span>ptr, <span class="nu0">0</span>, n <span class="sy2">*</span> <span class="kw3">sizeof</span> ptr<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">while</span> <span class="br0">&#40;</span><span class="kw4">int</span> pushed <span class="sy1">=</span> dfs <span class="br0">&#40;</span>s, INF<span class="br0">&#41;</span><span class="br0">&#41;</span>
			flow <span class="sy2">+</span><span class="sy1">=</span> pushed<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> flow<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Сеть должна быть предварительно считана: должны быть заданы переменные <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, а также считана матрица пропускных способностей <img class=tex src="../tex2png/cache/c82ff706ca1c13812c33e9dd4b08261c.png" alt="c[][]">. Основная функция решения &mdash; <img class=tex src="../tex2png/cache/950056bbc08a3f94d84f8c84bde8147e.png" alt="\rm dinic()">, которая возвращает величину найденного максимального потока.<p><p><h3 style="padding-top:15px;"> Реализация над графами в виде списков смежности </h3><p><pre class="notranslate cpp"><span class="kw4">const</span> <span class="kw4">int</span> MAXN <span class="sy1">=</span> ...<span class="sy4">;</span> <span class="co1">// число вершин</span>
<span class="kw4">const</span> <span class="kw4">int</span> INF <span class="sy1">=</span> <span class="nu0">1000000000</span><span class="sy4">;</span> <span class="co1">// константа-бесконечность</span>
&nbsp;
<span class="kw4">struct</span> edge <span class="br0">&#123;</span>
	<span class="kw4">int</span> a, b, cap, flow<span class="sy4">;</span>
<span class="br0">&#125;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">int</span> n, s, t, d<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, ptr<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span>, q<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
vector<span class="sy1">&lt;</span>edge<span class="sy1">&gt;</span> e<span class="sy4">;</span>
vector<span class="sy1">&lt;</span><span class="kw4">int</span><span class="sy1">&gt;</span> g<span class="br0">&#91;</span>MAXN<span class="br0">&#93;</span><span class="sy4">;</span>
&nbsp;
<span class="kw4">void</span> add_edge <span class="br0">&#40;</span><span class="kw4">int</span> a, <span class="kw4">int</span> b, <span class="kw4">int</span> cap<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	edge e1 <span class="sy1">=</span> <span class="br0">&#123;</span> a, b, cap, <span class="nu0">0</span> <span class="br0">&#125;</span><span class="sy4">;</span>
	edge e2 <span class="sy1">=</span> <span class="br0">&#123;</span> b, a, <span class="nu0">0</span>, <span class="nu0">0</span> <span class="br0">&#125;</span><span class="sy4">;</span>
	g<span class="br0">&#91;</span>a<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> e.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	e.<span class="me1">push_back</span> <span class="br0">&#40;</span>e1<span class="br0">&#41;</span><span class="sy4">;</span>
	g<span class="br0">&#91;</span>b<span class="br0">&#93;</span>.<span class="me1">push_back</span> <span class="br0">&#40;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span> e.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	e.<span class="me1">push_back</span> <span class="br0">&#40;</span>e2<span class="br0">&#41;</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">bool</span> bfs<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> qh<span class="sy1">=</span><span class="nu0">0</span>, qt<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span>
	q<span class="br0">&#91;</span>qt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> s<span class="sy4">;</span>
	<span class="kw3">memset</span> <span class="br0">&#40;</span>d, <span class="sy2">-</span><span class="nu0">1</span>, n <span class="sy2">*</span> <span class="kw3">sizeof</span> d<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
	d<span class="br0">&#91;</span>s<span class="br0">&#93;</span> <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">while</span> <span class="br0">&#40;</span>qh <span class="sy1">&lt;</span> qt <span class="sy3">&amp;&amp;</span> d<span class="br0">&#91;</span>t<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> v <span class="sy1">=</span> q<span class="br0">&#91;</span>qh<span class="sy2">++</span><span class="br0">&#93;</span><span class="sy4">;</span>
		<span class="kw1">for</span> <span class="br0">&#40;</span><span class="kw4">size_t</span> i<span class="sy1">=</span><span class="nu0">0</span><span class="sy4">;</span> i<span class="sy1">&lt;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>i<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			<span class="kw4">int</span> id <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>i<span class="br0">&#93;</span>,
				to <span class="sy1">=</span> e<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">b</span><span class="sy4">;</span>
			<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">==</span> <span class="sy2">-</span><span class="nu0">1</span> <span class="sy3">&amp;&amp;</span> e<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">flow</span> <span class="sy1">&lt;</span> e<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">cap</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
				q<span class="br0">&#91;</span>qt<span class="sy2">++</span><span class="br0">&#93;</span> <span class="sy1">=</span> to<span class="sy4">;</span>
				d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy1">=</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="sy4">;</span>
			<span class="br0">&#125;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> d<span class="br0">&#91;</span>t<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> <span class="sy2">-</span><span class="nu0">1</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> dfs <span class="br0">&#40;</span><span class="kw4">int</span> v, <span class="kw4">int</span> flow<span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>flow<span class="br0">&#41;</span>  <span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">if</span> <span class="br0">&#40;</span>v <span class="sy1">==</span> t<span class="br0">&#41;</span>  <span class="kw1">return</span> flow<span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;</span> ptr<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="sy1">&lt;</span><span class="br0">&#40;</span><span class="kw4">int</span><span class="br0">&#41;</span>g<span class="br0">&#91;</span>v<span class="br0">&#93;</span>.<span class="me1">size</span><span class="br0">&#40;</span><span class="br0">&#41;</span><span class="sy4">;</span> <span class="sy2">++</span>ptr<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw4">int</span> id <span class="sy1">=</span> g<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#91;</span>ptr<span class="br0">&#91;</span>v<span class="br0">&#93;</span><span class="br0">&#93;</span>,
			to <span class="sy1">=</span> e<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">b</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>d<span class="br0">&#91;</span>to<span class="br0">&#93;</span> <span class="sy3">!</span><span class="sy1">=</span> d<span class="br0">&#91;</span>v<span class="br0">&#93;</span> <span class="sy2">+</span> <span class="nu0">1</span><span class="br0">&#41;</span>  <span class="kw1">continue</span><span class="sy4">;</span>
		<span class="kw4">int</span> pushed <span class="sy1">=</span> dfs <span class="br0">&#40;</span>to, min <span class="br0">&#40;</span>flow, e<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">cap</span> <span class="sy2">-</span> e<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">flow</span><span class="br0">&#41;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span>pushed<span class="br0">&#41;</span> <span class="br0">&#123;</span>
			e<span class="br0">&#91;</span>id<span class="br0">&#93;</span>.<span class="me1">flow</span> <span class="sy2">+</span><span class="sy1">=</span> pushed<span class="sy4">;</span>
			e<span class="br0">&#91;</span>id<span class="sy3">^</span><span class="nu0">1</span><span class="br0">&#93;</span>.<span class="me1">flow</span> <span class="sy2">-</span><span class="sy1">=</span> pushed<span class="sy4">;</span>
			<span class="kw1">return</span> pushed<span class="sy4">;</span>
		<span class="br0">&#125;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> <span class="nu0">0</span><span class="sy4">;</span>
<span class="br0">&#125;</span>
&nbsp;
<span class="kw4">int</span> dinic<span class="br0">&#40;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
	<span class="kw4">int</span> flow <span class="sy1">=</span> <span class="nu0">0</span><span class="sy4">;</span>
	<span class="kw1">for</span> <span class="br0">&#40;</span><span class="sy4">;;</span><span class="br0">&#41;</span> <span class="br0">&#123;</span>
		<span class="kw1">if</span> <span class="br0">&#40;</span><span class="sy3">!</span>bfs<span class="br0">&#40;</span><span class="br0">&#41;</span><span class="br0">&#41;</span>  <span class="kw1">break</span><span class="sy4">;</span>
		<span class="kw3">memset</span> <span class="br0">&#40;</span>ptr, <span class="nu0">0</span>, n <span class="sy2">*</span> <span class="kw3">sizeof</span> ptr<span class="br0">&#91;</span><span class="nu0">0</span><span class="br0">&#93;</span><span class="br0">&#41;</span><span class="sy4">;</span>
		<span class="kw1">while</span> <span class="br0">&#40;</span><span class="kw4">int</span> pushed <span class="sy1">=</span> dfs <span class="br0">&#40;</span>s, INF<span class="br0">&#41;</span><span class="br0">&#41;</span>
			flow <span class="sy2">+</span><span class="sy1">=</span> pushed<span class="sy4">;</span>
	<span class="br0">&#125;</span>
	<span class="kw1">return</span> flow<span class="sy4">;</span>
<span class="br0">&#125;</span></pre><p>Сеть должна быть предварительно считана: должны быть заданы переменные <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n">, <img class=tex src="../tex2png/cache/342d607718e99ee38ba275df55ced44e.png" alt="s">, <img class=tex src="../tex2png/cache/668c0ed766381807a81b9a534a4a70ce.png" alt="t">, а также добавлены все рёбра (ориентированные) с помощью вызовов функции <img class=tex src="../tex2png/cache/097925bfdc3d6e3ea54caf185c401d3d.png" alt="\rm add\_edge">. Основная функция решения &mdash; <img class=tex src="../tex2png/cache/950056bbc08a3f94d84f8c84bde8147e.png" alt="\rm dinic()">, которая возвращает величину найденного максимального потока.<p><p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>