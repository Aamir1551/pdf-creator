<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd"><html><head><title>MAXimal :: algo :: Heavy-light декомпозиция</title><meta http-equiv="Content-Type" content="text/html; charset=windows-1251"><meta name="author" lang="ru" content="e-maxx" /><meta name="description" content="Алгоритмы, олимпиадное программирование, математика" /><meta name="keywords" content="алгоритмы программирование" /><meta name="google-site-verification" content="Pnjjj2XuxB0CTiqgDDvkp79bfSeDQ8Vw57iNeDJZkSc" /><link rel="stylesheet" type="text/css" href="../data/style.css"><script type="text/javascript" src="/data/jquery.js"></script><script type="text/javascript" src="/data/page-contents.js"></script><link rel="stylesheet" type="text/css" href="../geshi/geshi.css"><!--[if IE]><style>.menu a, .menu a:hover { width: 100%; }</style><![endif]--></head><body><table class=main cellpadding=0 cellspacing=0><tr><td class=title colspan=2><p>MAXimal</p></td></tr><tr><td class=menu><ul><li><a href="../index.php" >home</a></li><li><a href="../algo/" class=current>algo</a></li><li><a href="../bookz/" >bookz</a></li><li><a href="../forum/" >forum</a></li><li><a href="../about.php" >about</a></li></ul></td><td class=content><p class=algoinfo>добавлено: 6 Sep 2011 1:03<br>редактировано: 16 Nov 2011 23:48</p><div id="contents-table"><p id="contents-table-title">Содержание <a href="#" id="contents-hide">[скрыть]</a><a href="#" id="contents-show" style="display:none">[показать]</a></p><div style="display:none"></div></div><h1> Heavy-light декомпозиция </h1><p><b>Heavy-light декомпозиция</b> &mdash; это достаточно общий приём, который позволяет эффективно решать многие задачи, сводящиеся к <b>запросам на дереве</b>.<p>Простейший <b>пример</b> задач такого вида &mdash; это следующая задача. Дано дерево, каждой вершине которого приписано какое-то число. Поступают запросы вида <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)">, где <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; номера вершин дерева, и требуется узнать максимальное число на пути между вершинами <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">.<p><p><h2 style="padding-top:40px;"> Описание алгоритма </h2><p>Итак, пусть дано дерево <img class=tex src="../tex2png/cache/4c5f3ba22ad1fd775e82380ae681dbdb.png" alt="G"> с <img class=tex src="../tex2png/cache/8bc19c5640342f9c5ad0ba16baf59981.png" alt="n"> вершинами, подвешенное за некоторый корень.<p>Суть этой декомпозиции в том, чтобы <b>разбить дерево на несколько путей</b> таким образом, чтобы для любой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> получалось, что если мы будем подниматься от <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> к корню, то по пути сменим не более <img class=tex src="../tex2png/cache/6839f55793e4e69dcc7f4ca7caed0770.png" alt="\log n"> путей. Кроме того, все пути должны не пересекаться друг с другом по рёбрам.<p>Понятно, что если мы научимся искать такую декомпозицию для любого дерева, это позволит свести любой запрос вида "узнать что-то на пути из <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> в <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">" к нескольким запросам вида "узнать что-то на отрезке <img class=tex src="../tex2png/cache/26853b907ea3f6227b00c5afac10292a.png" alt="[l;r]"> <img class=tex src="../tex2png/cache/252410059470b019db6fd4c3b844a348.png" alt="k">-го пути".<p><p><h3 style="padding-top:15px;"> Построение heavy-light декомпозиции </h3><p>Посчитаем для каждой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> размер её поддерева <img class=tex src="../tex2png/cache/5481a672ae022a2cb98d6f5199e5e8f0.png" alt="s(v)"> (т.е. это количество вершин в поддереве вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">, включая саму вершину).<p>Далее, рассмотрим все рёбра, ведущие к сыновьям какой-либо вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v">. Назовём ребро <img class=tex src="../tex2png/cache/5a5cc161c081abd04b4bf978827a3880.png" alt="(v,c)"> <b>тяжёлым</b>, если оно ведёт в вершину <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> такую, что:<p><p class=formula><img class=tex src="../tex2png/cache/7e1adc211a0cf920b1dbc0cb461809ca.png" alt=" s(c) \ge \frac{ s(v) }{ 2 } ~~~~ \Leftrightarrow [...]"></p><p>Все остальные рёбра назовём <b>лёгкими</b>. Очевидно, что из одной вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> вниз может исходить максимум одно тяжёлое ребро (т.к. в противном случае у вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> было бы два сына размера <img class=tex src="../tex2png/cache/9e45802b65ac21676ca8b1778d4759a5.png" alt="s(v)/2">, что с учётом самой вершины <img class=tex src="../tex2png/cache/9530057de1d317139fef00be858ff2f1.png" alt="v"> даёт размер <img class=tex src="../tex2png/cache/120f4f20927ddd8b7fd0cb8631cf49ee.png" alt="2 \cdot s(v) / 2 + 1 > s(v)">, т.е. пришли к противоречию).<p>Теперь построим саму <b>декомпозицию</b> дерева на непересекающиеся пути. Рассмотрим все вершины, из которых не выходит вниз ни одного тяжёлого ребра, и будем идти от каждой из них вверх, пока не дойдём до корня дерева или не пройдём лёгкое ребро. В результате мы получим несколько путей &mdash; покажем, что это и есть искомые пути heavy-light декомпозиции.<p><p><h3 style="padding-top:15px;"> Доказательство корректности алгоритма </h3><p>Во-первых, заметим, что полученные алгоритмом пути будут <b>непересекающимися</b>. В самом деле, если бы два каких-то пути имели бы общее ребро, это бы означало, что из какой-то вершины исходит вниз два тяжёлых ребра, чего быть не может.<p>Во-вторых, покажем, что спускаясь от корня дерева до произвольной вершины, мы <b>сменим по пути не более <img class=tex src="../tex2png/cache/6839f55793e4e69dcc7f4ca7caed0770.png" alt="\log n"> путей</b>. В самом деле, проход вниз по лёгкому ребру уменьшает размер текущего поддерева более чем вдвое:<p><p class=formula><img class=tex src="../tex2png/cache/7a8de12630f4130b1c0a95a6aa7dfbe5.png" alt=" s(c) < \frac{ s(v) }{ 2 } ~~~~ \Leftrightarrow ~~[...]"></p><p>Таким образом, мы не могли пройти более <img class=tex src="../tex2png/cache/6839f55793e4e69dcc7f4ca7caed0770.png" alt="\log n"> лёгких рёбер. Однако переходить с одного пути на другой мы можем только через лёгкое ребро (т.к. каждый путь, кроме заканчивающихся в корне, содержит лёгкое ребро в конце; а попасть сразу посередине пути мы не можем).<p>Следовательно, по пути от корня до любой вершины мы не можем сменить более <img class=tex src="../tex2png/cache/6839f55793e4e69dcc7f4ca7caed0770.png" alt="\log n"> путей, что и требовалось доказать.<p><p><h2 style="padding-top:40px;"> Применения при решении задач </h2><p>При решении задач иногда бывает удобнее рассматривать heavy-light как набор <b>вершинно-непересекающихся</b> путей (а не рёберо-непересекающихся). Для этого достаточно из каждого пути исключить последнее ребро, если оно являются лёгким ребром &mdash; тогда никакие свойства не нарушатся, но теперь каждая вершина будет принадлежать ровно одному пути.<p>Ниже мы рассмотрим несколько типичных задач, которые можно решать с помощью heavy-light декомпозиции.<p>Отдельно стоит обратить внимание на задачу <b>сумма чисел на пути</b>, поскольку это пример задачи, которая может быть решена и более простыми техниками.<p><p><h3 style="padding-top:15px;"> Максимальное число на пути между двумя вершинами </h3><p>Дано дерево, каждой вершине которого приписано какое-то число. Поступают запросы вида <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)">, где <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; номера вершин дерева, и требуется узнать максимальное число на пути между вершинами <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">.<p>Построим заранее heavy-light декомпозицию. Над каждым получившимся путём построим <a href="segment_tree">дерево отрезков для максимума</a>, что позволит искать вершину с максимальным приписанным числом в указанном сегменте указанного пути за <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)">. Хотя число путей в heavy-light декомпозиции может достигать <img class=tex src="../tex2png/cache/0409310e642143903bd490e71e4a951e.png" alt="n-1">, суммарный размер всех путей есть величина <img class=tex src="../tex2png/cache/3bd5ae6ef1beefce202e062967bc49c1.png" alt="O(n)">, поэтому и суммарный размер деревьев отрезков также будет линейным.<p>Теперь, для того чтобы отвечать на поступивший запрос <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> найдём наименьшего общего предка <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> этих вершин (например, <a href="lca_simpler">методом двоичного подъёма</a>). Теперь задача свелась к двум запросам: <img class=tex src="../tex2png/cache/981d7679bfc39d1050b5e693d10eeaf9.png" alt="(a,l)"> и <img class=tex src="../tex2png/cache/45c996e45a770f47f1b186aeef2a90d6.png" alt="(b,l)">, на каждый из которых мы можем ответить таким образом: найдём, в каком пути лежит нижняя вершина, сделаем запрос к этому пути, перейдём в вершину-конец этого пути, снова определим, в каком мы пути оказались и сделаем запрос к нему, и так далее, пока не дойдём до пути, содержащего <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">.<p>Аккуратно следует быть со случаем, когда, например, <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> оказались в одном пути &mdash; тогда запрос максимума к этому пути надо делать не на суффиксе, а на внутреннем подотрезке.<p>Таким образом, в процессе ответа на один подзапрос мы пройдём по <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> путям, в каждом из них сделав запрос максимума на суффиксе или на префиксе/подотрезке (запрос на префиксе/подотрезке мог быть только один раз).<p>Так мы получили решение за <img class=tex src="../tex2png/cache/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\log^2 n)"> на один запрос.<p>Если ещё дополнительно предпосчитать на каждом пути максимумы на всех суффиксах, то получится решение за <img class=tex src="../tex2png/cache/65dae66ac82f684c5b24e464a8ca3610.png" alt="O (n \log n)"> &mdash; т.к. запрос максимума не на суффиксе случается только один раз, когда мы доходим до вершины <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l">.<p><p><h3 style="padding-top:15px;"> Сумма чисел на пути между двумя вершинами </h3><p>Дано дерево, каждой вершине которого приписано какое-то число. Поступают запросы вида <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)">, где <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; номера вершин дерева, и требуется узнать сумму чисел на пути между вершинами <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b">. Возможен вариант этой задачи, когда дополнительно бывают запросы изменения числа, приписанного той или иной вершине.<p>Хотя эту задачу можно решать с помощью heavy-light декомпозиции, построив над каждым путём дерево отрезков для суммы (или просто предпосчитав частичные суммы, если в задаче отсутствуют запросы изменения), эта задача может быть решена <b>более простыми техниками</b>.<p>Если запросы модификации отсутствуют, то узнавать сумму на пути между двумя вершинами можно параллельно с поиском LCA двух вершин в <a href="lca_simpler">алгоритме двоичного подъёма</a> &mdash; для этого достаточно во время препроцессинга для LCA подсчитывать не только <img class=tex src="../tex2png/cache/a631b6ee74bdfc6711813da7ca95a648.png" alt="2^k">-ых предков каждой вершины, но и сумму чисел на пути до этого предка.<p>Есть и принципиально другой подход к этой задаче &mdash; рассмотреть эйлеров обход дерева, и построить дерево отрезков над ним. Этот алгоритм рассматривается в <a href="tree_painting">статье с решением похожей задачи</a>. (А если запросы модификации отсутствуют &mdash; то достаточно обойтись предпосчётом частичных сумм, без дерева отрезков.)<p>Оба этих способа дают относительно простые решения с асимптотикой <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> на один запрос.<p><p><h3 style="padding-top:15px;"> Перекраска рёбер пути между двумя вершинами </h3><p>Дано дерево, каждое ребро изначально покрашено в белый цвет. Поступают запросы вида <img class=tex src="../tex2png/cache/6370ac792b4c361698fa737f033bfca2.png" alt="(a,b,c)">, где <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> &mdash; номера вершин, <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c"> &mdash; цвет, что означает, что все рёбра на пути из <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> в <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> надо перекрасить в цвет <img class=tex src="../tex2png/cache/fdabaa70e1c423d289836bd4624e9e4e.png" alt="c">. Требуется после всех перекрашиваний сообщить, сколько в итоге получилось рёбер каждого цвета.<p>Решение &mdash; просто сделать <a href="segment_tree">дерево отрезков с покраской на отрезке</a> над набором путей heavy-light декомпозиции.<p>Каждый запрос перекраски на пути <img class=tex src="../tex2png/cache/f66f01c0505eda5e6e0f27520b4289b0.png" alt="(a,b)"> превратится в два подзапроса <img class=tex src="../tex2png/cache/981d7679bfc39d1050b5e693d10eeaf9.png" alt="(a,l)"> и <img class=tex src="../tex2png/cache/45c996e45a770f47f1b186aeef2a90d6.png" alt="(b,l)">, где <img class=tex src="../tex2png/cache/c389ea8fa0131816bbcd01a1fbacec19.png" alt="l"> &mdash; наименьший общий предок вершин <img class=tex src="../tex2png/cache/e4c9b6bf3a65f2e487e7cb3e199f2154.png" alt="a"> и <img class=tex src="../tex2png/cache/64e10b28938db2ba8a2b9fabb72a2cd9.png" alt="b"> (найденный, например, <a href="lca_simpler">алгоритмом двоичного подъёма</a>), а каждый из этих подзапросов &mdash; в <img class=tex src="../tex2png/cache/f164aa195cc12acf4e3719819f08c698.png" alt="O (\log n)"> запросов к деревьям отрезков над путями.<p>Итого получается решение с асимптотикой <img class=tex src="../tex2png/cache/5f31d6f46e03579a1025f178e6d85150.png" alt="O (\log^2 n)"> на один запрос.<p><p><p><h2 style="padding-top:40px;"> Задачи в online judges </h2><p>Список задач, которые можно решить, используя heavy-light декомпозицию:<p><ul><p><li><a href="http://acm.timus.ru/problem.aspx?space=1&num=1553">TIMUS #1553 <b>"Caves and Tunnels"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://ipsc.ksp.sk/contests/ipsc2009/real/problems/l.php">IPSC 2009 L <b>"Let there be rainbows!"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://www.spoj.pl/problems/QTREE3/">SPOJ #2798 <b>"Query on a tree again!"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: средняя]</a><p><li><a href="http://codeforces.ru/contest/117/problem/E">Codeforces Beta Round #88 E <b>"Дерево или не дерево"</b> &nbsp;&nbsp;&nbsp;&nbsp; [сложность: высокая] </a><p></ul><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><p>&nbsp;</p><hr><p>
<div id="disqus_thread"></div>
<script type="text/javascript">
    var disqus_shortname = 'e-maxx';
    (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = 'http://' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    })();
</script></td></tr></table></body></html>